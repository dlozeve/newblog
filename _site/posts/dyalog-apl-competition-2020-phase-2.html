<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=yes">
    <meta name="description" content="Dimitri Lozeve's blog: Dyalog APL Problem Solving Competition 2020 — Phase II">
    
    <title>Dimitri Lozeve - Dyalog APL Problem Solving Competition 2020 — Phase II</title>
    <link rel="stylesheet" href="../css/tufte.css" />
    <link rel="stylesheet" href="../css/pandoc.css" />
    <link rel="stylesheet" href="../css/default.css" />
    <link rel="stylesheet" href="../css/syntax.css" />

    <!-- RSS feed -->
    <link rel="alternate" type="application/rss+xml" title="Dimitri Lozeve's blog" href="../rss.xml" /> 

    <!-- KaTeX CSS styles -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.0/dist/katex.min.css" integrity="sha384-BdGj8xC2eZkQaxoQ8nSLefg4AV4/AwB3Fj+8SUSo7pnKP6Eoy18liIKTPn9oBYNG" crossorigin="anonymous">

    <!-- The loading of KaTeX is deferred to speed up page rendering -->
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.0/dist/katex.min.js" integrity="sha384-JiKN5O8x9Hhs/UE5cT5AAJqieYlOZbGT3CHws/y97o3ty4R7/O5poG9F3JoiOYw1" crossorigin="anonymous"></script>

    <!-- To automatically render math in text elements, include the auto-render extension: -->
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.0/dist/contrib/auto-render.min.js" integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous" onload="renderMathInElement(document.body);"></script>
 
  </head>
  <body>
    <article>
      
      <header>
	<nav>
          <a href="../">Home</a>
	  <a href="../projects.html">Projects</a>
          <a href="../archive.html">Archive</a>
	  <a href="../contact.html">Contact</a>
	</nav>

	<h1 class="title">Dyalog APL Problem Solving Competition 2020 — Phase II</h1>
	
	<p class="subtitle">Annotated Solutions</p>
	
	
	<p class="byline">August  2, 2020</p>
	
      </header>
      

      
    </article>

    <article>
    <section class="header">
        
    </section>
    <section>
        <h2>Table of Contents</h2><ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#problem-1-take-a-dive">Problem 1 – Take a Dive</a></li>
<li><a href="#problem-2-another-step-in-the-proper-direction">Problem 2 – Another Step in the Proper Direction</a></li>
<li><a href="#problem-3-past-tasks-blast">Problem 3 – Past Tasks Blast</a></li>
<li><a href="#problem-4-bioinformatics">Problem 4 – Bioinformatics</a></li>
<li><a href="#problem-5-future-and-present-value">Problem 5 – Future and Present Value</a></li>
<li><a href="#problem-6-merge">Problem 6 – Merge</a></li>
<li><a href="#problem-7-upc">Problem 7 – UPC</a></li>
<li><a href="#problem-8-balancing-the-scales">Problem 8 – Balancing the Scales</a></li>
<li><a href="#problem-9-upwardly-mobile">Problem 9 – Upwardly Mobile</a></li>
</ul>
<h2 id="introduction">Introduction</h2>
<p>After <a href="./dyalog-apl-competition-2020-phase-1.html">Phase I</a>, here are my solutions to Phase II problems. The full code is included in the post, but everything is also available <a href="https://github.com/dlozeve/apl-competition-2020">on GitHub</a>.</p>
<p>A PDF of the problems descriptions is available on <a href="https://www.dyalogaplcompetition.com/">the competition website</a>, or directly from <a href="https://github.com/dlozeve/apl-competition-2020/blob/master/Contest2020/2020%20APL%20Problem%20Solving%20Competition%20Phase%20II%20Problems.pdf">my GitHub repo</a>.</p>
<p>The submission guidelines gave a template where everything is defined in a <code>Contest2020.Problems</code> Namespace. I kept the default values for <code>⎕IO</code> and <code>⎕ML</code> because the problems were not particularly easier with <code>⎕IO←0</code>.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode default"><code class="sourceCode default"><a class="sourceLine" id="cb1-1" title="1">:Namespace Contest2020</a>
<a class="sourceLine" id="cb1-2" title="2"></a>
<a class="sourceLine" id="cb1-3" title="3">    :Namespace Problems</a>
<a class="sourceLine" id="cb1-4" title="4">        (⎕IO ⎕ML ⎕WX)←1 1 3</a></code></pre></div>
<h2 id="problem-1-take-a-dive">Problem 1 – Take a Dive</h2>
<div class="sourceCode" id="cb2"><pre class="sourceCode default"><code class="sourceCode default"><a class="sourceLine" id="cb2-1" title="1">∇ score←dd DiveScore scores</a>
<a class="sourceLine" id="cb2-2" title="2">  :If 7=≢scores</a>
<a class="sourceLine" id="cb2-3" title="3">      scores←scores[¯2↓2↓⍋scores]</a>
<a class="sourceLine" id="cb2-4" title="4">  :ElseIf 5=≢scores</a>
<a class="sourceLine" id="cb2-5" title="5">      scores←scores[¯1↓1↓⍋scores]</a>
<a class="sourceLine" id="cb2-6" title="6">  :Else</a>
<a class="sourceLine" id="cb2-7" title="7">      scores←scores</a>
<a class="sourceLine" id="cb2-8" title="8">  :EndIf</a>
<a class="sourceLine" id="cb2-9" title="9">  score←2(⍎⍕)dd×+/scores</a>
<a class="sourceLine" id="cb2-10" title="10">∇</a></code></pre></div>
<p>This is a very straightforward implementation of the algorithm describe in the problem description. I decided to switch explicitly on the size of the input vector because I feel it is more natural. For the cases with 5 or 7 judges, we use Drop (<code>↓</code>) to remove the lowest and highest scores.</p>
<p>At the end, we sum up the scores with <code>+/</code> and multiply them by <code>dd</code>. The last operation, <code>2(⍎⍕)</code>, is a train using <a href="https://help.dyalog.com/18.0/index.htm#Language/Primitive%20Functions/Format%20Dyadic.htm">Format (Dyadic)</a> to round to 2 decimal places, and <a href="https://help.dyalog.com/18.0/index.htm#Language/Primitive%20Functions/Execute.htm">Execute</a> to get actual numbers and not strings.</p>
<h2 id="problem-2-another-step-in-the-proper-direction">Problem 2 – Another Step in the Proper Direction</h2>
<div class="sourceCode" id="cb3"><pre class="sourceCode default"><code class="sourceCode default"><a class="sourceLine" id="cb3-1" title="1">∇ steps←{p}Steps fromTo;segments;width</a>
<a class="sourceLine" id="cb3-2" title="2">  width←|-/fromTo</a>
<a class="sourceLine" id="cb3-3" title="3">  :If 0=⎕NC'p' ⍝ No left argument: same as Problem 5 of Phase I</a>
<a class="sourceLine" id="cb3-4" title="4">      segments←0,⍳width</a>
<a class="sourceLine" id="cb3-5" title="5">  :ElseIf p&lt;0 ⍝ -⌊p is the number of equally-sized steps to take</a>
<a class="sourceLine" id="cb3-6" title="6">      segments←(-⌊p){0,⍵×⍺÷⍨⍳⍺}width</a>
<a class="sourceLine" id="cb3-7" title="7">  :ElseIf p&gt;0 ⍝ p is the step size</a>
<a class="sourceLine" id="cb3-8" title="8">      segments←p{⍵⌊⍺×0,⍳⌈⍵÷⍺}width</a>
<a class="sourceLine" id="cb3-9" title="9">  :ElseIf p=0 ⍝ As if we took zero step</a>
<a class="sourceLine" id="cb3-10" title="10">      segments←0</a>
<a class="sourceLine" id="cb3-11" title="11">  :EndIf</a>
<a class="sourceLine" id="cb3-12" title="12">  ⍝ Take into account the start point and the direction.</a>
<a class="sourceLine" id="cb3-13" title="13">  steps←fromTo{(⊃⍺)+(-×-/⍺)×⍵}segments</a>
<a class="sourceLine" id="cb3-14" title="14">∇</a></code></pre></div>
<p>This is an extension to <a href="./dyalog-apl-competition-2020-phase-1.html#stepping-in-the-proper-direction">Problem 5 of Phase I</a>. In each case, we compute the “segments”, i.e., the steps starting from 0. In a last step, common to all cases, we add the correct starting point and correct the direction if need be.</p>
<p>To compute equally-sized steps, we first divide the segment <span class="math inline">\([0, 1]\)</span> in <code>p</code> equal segments with <code>(⍳p)÷p</code>. This subdivision can then be multiplied by the width to obtain the required segments.</p>
<p>When <code>p</code> is the step size, we just divide the width by the step size (rounded to the next largest integer) to get the required number of segments. If the last segment is too large, we “crop” it to the width with Minimum (<code>⌊</code>).</p>
<h2 id="problem-3-past-tasks-blast">Problem 3 – Past Tasks Blast</h2>
<div class="sourceCode" id="cb4"><pre class="sourceCode default"><code class="sourceCode default"><a class="sourceLine" id="cb4-1" title="1">∇ urls←PastTasks url;r;paths</a>
<a class="sourceLine" id="cb4-2" title="2">  r←HttpCommand.Get url</a>
<a class="sourceLine" id="cb4-3" title="3">  paths←('[a-zA-Z0-9_/]+\.pdf'⎕S'&amp;')r.Data</a>
<a class="sourceLine" id="cb4-4" title="4">  urls←('https://www.dyalog.com/'∘,)¨paths</a>
<a class="sourceLine" id="cb4-5" title="5">∇</a></code></pre></div>
<p>I decided to use <code>HttpCommand</code> for this task, since it is simply one <code>]load HttpCommand</code> away and should be platform-independent.</p>
<p>Parsing XML is not something I consider “fun” in the best of cases, and I feel like APL is not the best language to do this kind of thing. Given how simple the task is, I just decided to find the relevant bits with a regular expression using <a href="https://help.dyalog.com/18.0/index.htm#Language/System%20Functions/r.htm">Replace and Search</a> (<code>⎕S</code>).</p>
<p>After finding all the strings vaguely resembling a PDF file name (only alphanumeric characters and underscores, with a <code>.pdf</code> extension), I just concatenate them to the base URL of the Dyalog domain.</p>
<h2 id="problem-4-bioinformatics">Problem 4 – Bioinformatics</h2>
<p>The first task can be solved by decomposing it into several functions.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode default"><code class="sourceCode default"><a class="sourceLine" id="cb5-1" title="1">⍝ Test if a DNA string is a reverse palindrome.</a>
<a class="sourceLine" id="cb5-2" title="2">isrevp←{⍵≡⌽'TAGC'['ATCG'⍳⍵]}</a></code></pre></div>
<p>First, we compute the complement of a DNA string (using simple indexing) and test if its Reverse (<code>⌽</code>) is equal to the original string.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode default"><code class="sourceCode default"><a class="sourceLine" id="cb6-1" title="1">⍝ Generate all subarrays (position, length) pairs, for 4 ≤ length ≤ 12.</a>
<a class="sourceLine" id="cb6-2" title="2">subarrays←{⊃,/(⍳⍵),¨¨3↓¨⍳¨12⌊1+⍵-⍳⍵}</a></code></pre></div>
<p>We first compute all the possible lengths for each starting point. For instance, the last element cannot have any (position, length) pair associated to it, because there is no three element following it. So we crop the possible lengths to <span class="math inline">\([3, 12]\)</span>. For instance for an array of size 10:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode default"><code class="sourceCode default"><a class="sourceLine" id="cb7-1" title="1">        {3↓¨⍳¨12⌊1+⍵-⍳⍵}10</a>
<a class="sourceLine" id="cb7-2" title="2">┌──────────────┬───────────┬─────────┬───────┬─────┬───┬─┬┬┬┐</a>
<a class="sourceLine" id="cb7-3" title="3">│4 5 6 7 8 9 10│4 5 6 7 8 9│4 5 6 7 8│4 5 6 7│4 5 6│4 5│4││││</a>
<a class="sourceLine" id="cb7-4" title="4">└──────────────┴───────────┴─────────┴───────┴─────┴───┴─┴┴┴┘</a></code></pre></div>
<p>Then, we just add the corresponding starting position to each length (1 for the first block, 2 for the second, and so on). Finally, we flatten everything.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode default"><code class="sourceCode default"><a class="sourceLine" id="cb8-1" title="1">∇ r←revp dna;positions</a>
<a class="sourceLine" id="cb8-2" title="2">  positions←subarrays⍴dna</a>
<a class="sourceLine" id="cb8-3" title="3">  ⍝ Filter subarrays which are reverse palindromes.</a>
<a class="sourceLine" id="cb8-4" title="4">  r←↑({isrevp dna[¯1+⍵[1]+⍳⍵[2]]}¨positions)/positions</a>
<a class="sourceLine" id="cb8-5" title="5">∇</a></code></pre></div>
<p>For each possible (position, length) pair, we get the corresponding DNA substring with <code>dna[¯1+⍵[1]+⍳⍵[2]]</code> (adding <code>¯1</code> is necessary because <code>⎕IO←1</code>). We test if this substring is a reverse palindrome using <code>isrevp</code> above. <a href="https://help.dyalog.com/18.0/index.htm#Language/Primitive%20Functions/Replicate.htm">Replicate</a> (<code>/</code>) then selects only the (position, length) pairs for which the substring is a reverse palindrome.</p>
<p>The second task is just about counting the number of subsets modulo 1,000,000. So we just need to compute <span class="math inline">\(2^n \mod 1000000\)</span> for any positive integer <span class="math inline">\(n\leq1000\)</span>.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode default"><code class="sourceCode default"><a class="sourceLine" id="cb9-1" title="1">sset←{((1E6|2∘×)⍣⍵)1}</a></code></pre></div>
<p>Since we cannot just compute <span class="math inline">\(2^n\)</span> directly and take the remainder, we use modular arithmetic to stay mod 1,000,000 during the whole computation. The dfn <code>(1E6|2∘×)</code> doubles its argument mod 1,000,000. So we just apply this function <span class="math inline">\(n\)</span> times using the <a href="https://help.dyalog.com/18.0/index.htm#Language/Primitive%20Operators/Power%20Operator.htm">Power</a> operator (<code>⍣</code>), with an initial value of 1.</p>
<h2 id="problem-5-future-and-present-value">Problem 5 – Future and Present Value</h2>
<p>First solution: <code>((1+⊢)⊥⊣)</code> computes the total return for a vector of amounts <code>⍺</code> and a vector of rates <code>⍵</code>. It is applied to every prefix subarray of amounts and rates to get all intermediate values. However, this has quadratic complexity.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode default"><code class="sourceCode default"><a class="sourceLine" id="cb10-1" title="1">rr←(,\⊣)((1+⊢)⊥⊣)¨(,\⊢)</a></code></pre></div>
<p>Second solution: We want to be able to use the recurrence relation (<code>recur</code>) and scan through the vectors of amounts and rates, accumulating the total value at every time step. However, APL evaluation is right-associative, so a simple <a href="https://help.dyalog.com/18.0/index.htm#Language/Primitive%20Operators/Scan.htm">Scan</a> (<code>recur\amounts,¨values</code>) would not give the correct result, since <code>recur</code> is not associative and we need to evaluate it left-to-right. (In any case, in this case, Scan would have quadratic complexity, so would not bring any benefit over the previous solution.) What we need is something akin to Haskell’s <code>scanl</code> function, which would evaluate left to right in <span class="math inline">\(O(n)\)</span> time<span><label for="sn-1" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-1" class="margin-toggle" /><span class="sidenote">There is an interesting <a href="https://stackoverflow.com/a/25100675/8864368">StackOverflow answer</a> explaining the behaviour of Scan, and compares it to Haskell’s <code>scanl</code> function.<br />
<br />
</span></span>. This is what we do here, accumulating values from left to right. (This is inspired from <a href="https://dfns.dyalog.com/c_ascan.htm"><code>dfns.ascan</code></a>, although heavily simplified.)</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode default"><code class="sourceCode default"><a class="sourceLine" id="cb11-1" title="1">rr←{recur←{⍵[1]+⍺×1+⍵[2]} ⋄ 1↓⌽⊃{(⊂(⊃⍵)recur⍺),⍵}/⌽⍺,¨⍵}</a></code></pre></div>
<p>For the second task, there is an explicit formula for cashflow calculations, so we can just apply it.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode default"><code class="sourceCode default"><a class="sourceLine" id="cb12-1" title="1">pv←{+/⍺÷×\1+⍵}</a></code></pre></div>
<h2 id="problem-6-merge">Problem 6 – Merge</h2>
<div class="sourceCode" id="cb13"><pre class="sourceCode default"><code class="sourceCode default"><a class="sourceLine" id="cb13-1" title="1">∇ text←templateFile Merge jsonFile;template;ns</a>
<a class="sourceLine" id="cb13-2" title="2">  template←⊃⎕NGET templateFile 1</a>
<a class="sourceLine" id="cb13-3" title="3">  ns←⎕JSON⊃⎕NGET jsonFile</a>
<a class="sourceLine" id="cb13-4" title="4">  ⍝ We use a simple regex search and replace on the</a>
<a class="sourceLine" id="cb13-5" title="5">  ⍝ template.</a>
<a class="sourceLine" id="cb13-6" title="6">  text←↑('@[a-zA-Z]*@'⎕R{ns getval ¯1↓1↓⍵.Match})template</a>
<a class="sourceLine" id="cb13-7" title="7">∇</a></code></pre></div>
<p>We first read the template and the JSON values from their files. The <a href="https://help.dyalog.com/18.0/index.htm#Language/System%20Functions/nget.htm"><code>⎕NGET</code></a> function read simple text files, and <a href="https://help.dyalog.com/18.0/index.htm#Language/System%20Functions/json.htm"><code>⎕JSON</code></a> extracts the key-value pairs as a namespace.</p>
<p>Assuming all variable names contain only letters, we match the regex <code>@[a-zA-Z]*@</code> to match variable names enclosed between <code>@</code> symbols. The function <code>getval</code> then returns the appropriate value, and we can replace the variable name in the template.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode default"><code class="sourceCode default"><a class="sourceLine" id="cb14-1" title="1">∇ val←ns getval var</a>
<a class="sourceLine" id="cb14-2" title="2">  :If ''≡var ⍝ literal '@'</a>
<a class="sourceLine" id="cb14-3" title="3">      val←'@'</a>
<a class="sourceLine" id="cb14-4" title="4">  :ElseIf (⊂var)∊ns.⎕NL ¯2</a>
<a class="sourceLine" id="cb14-5" title="5">      val←⍕ns⍎var</a>
<a class="sourceLine" id="cb14-6" title="6">  :Else</a>
<a class="sourceLine" id="cb14-7" title="7">      val←'???'</a>
<a class="sourceLine" id="cb14-8" title="8">  :EndIf</a>
<a class="sourceLine" id="cb14-9" title="9">∇</a></code></pre></div>
<p>This function takes the namespace matching the variable names to their respective values, and the name of the variable.</p>
<ul>
<li>If the variable name is empty, we matched the string <code>@@</code>, which corresponds to a literal <code>@</code>.</li>
<li>If the variable name is present in the namespace, we query the namespace to get the required value.</li>
<li>Otherwise, we have an unknown variable, so we replace it with <code>???</code>.</li>
</ul>
<h2 id="problem-7-upc">Problem 7 – UPC</h2>
<div class="sourceCode" id="cb15"><pre class="sourceCode default"><code class="sourceCode default"><a class="sourceLine" id="cb15-1" title="1">CheckDigit←{10|-⍵+.×11⍴3 1}</a></code></pre></div>
<p>The check digit satisfies the equation <span class="math display">\[ 3 x_{1}+x_{2}+3 x_{3}+x_{4}+3 x_{5}+x_{6}+3 x_{7}+x_{8}+3 x_{9}+x_{10}+3 x_{11}+x_{12} \equiv 0 \bmod 10, \]</span> therefore, <span class="math display">\[ x_{12} \equiv -(3 x_{1}+x_{2}+3 x_{3}+x_{4}+3 x_{5}+x_{6}+3 x_{7}+x_{8}+3 x_{9}+x_{10}+3 x_{11}) \bmod 10. \]</span></p>
<p>Translated to APL, we just take the dot product between the first 11 digits of the barcode with <code>11⍴3 1</code>, negate it, and take the remainder by 10.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode default"><code class="sourceCode default"><a class="sourceLine" id="cb16-1" title="1">⍝ Left and right representations of digits. Decoding</a>
<a class="sourceLine" id="cb16-2" title="2">⍝ the binary representation from decimal is more</a>
<a class="sourceLine" id="cb16-3" title="3">⍝ compact than writing everything explicitly.</a>
<a class="sourceLine" id="cb16-4" title="4">lrepr←⍉(7⍴2)⊤13 25 19 61 35 49 47 59 55 11</a>
<a class="sourceLine" id="cb16-5" title="5">rrepr←~¨lrepr</a></code></pre></div>
<p>For the second task, the first thing we need to do is save the representation of digits. To save space, I did not encode the binary representation explicitly, instead using a decimal representation that I then decode in base 2. The right representation is just the bitwise negation.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode default"><code class="sourceCode default"><a class="sourceLine" id="cb17-1" title="1">∇ bits←WriteUPC digits;left;right</a>
<a class="sourceLine" id="cb17-2" title="2">  :If (11=≢digits)∧∧/digits∊0,⍳9</a>
<a class="sourceLine" id="cb17-3" title="3">      left←,lrepr[1+6↑digits;]</a>
<a class="sourceLine" id="cb17-4" title="4">      right←,rrepr[1+6↓digits,CheckDigit digits;]</a>
<a class="sourceLine" id="cb17-5" title="5">      bits←1 0 1,left,0 1 0 1 0,right,1 0 1</a>
<a class="sourceLine" id="cb17-6" title="6">  :Else</a>
<a class="sourceLine" id="cb17-7" title="7">      bits←¯1</a>
<a class="sourceLine" id="cb17-8" title="8">  :EndIf</a>
<a class="sourceLine" id="cb17-9" title="9">∇</a></code></pre></div>
<p>First of all, if the vector <code>digits</code> does not have exactly 11 elements, all between 0 and 9, it is an error and we return <code>¯1</code>.</p>
<p>Then, we take the first 6 digits and encode them with <code>lrepr</code>, and the last 5 digits plus the check digit encoded with <code>rrepr</code>. In each case, adding 1 is necessary because <code>⎕IO←1</code>. We return the final bit array with the required beginning, middle, and end guard patterns.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode default"><code class="sourceCode default"><a class="sourceLine" id="cb18-1" title="1">∇ digits←ReadUPC bits</a>
<a class="sourceLine" id="cb18-2" title="2">  :If 95≠⍴bits ⍝ incorrect number of bits</a>
<a class="sourceLine" id="cb18-3" title="3">      digits←¯1</a>
<a class="sourceLine" id="cb18-4" title="4">  :Else</a>
<a class="sourceLine" id="cb18-5" title="5">      ⍝ Test if the barcode was scanned right-to-left.</a>
<a class="sourceLine" id="cb18-6" title="6">      :If 0=2|+/bits[3+⍳7]</a>
<a class="sourceLine" id="cb18-7" title="7">          bits←⌽bits</a>
<a class="sourceLine" id="cb18-8" title="8">      :EndIf</a>
<a class="sourceLine" id="cb18-9" title="9">      digits←({¯1+lrepr⍳⍵}¨(7/⍳6)⊆42↑3↓bits),{¯1+rrepr⍳⍵}¨(7/⍳6)⊆¯42↑¯3↓bits</a>
<a class="sourceLine" id="cb18-10" title="10">      :If ~∧/digits∊0,⍳9 ⍝ incorrect parity</a>
<a class="sourceLine" id="cb18-11" title="11">          digits←¯1</a>
<a class="sourceLine" id="cb18-12" title="12">      :ElseIf (⊃⌽digits)≠CheckDigit ¯1↓digits ⍝ incorrect check digit</a>
<a class="sourceLine" id="cb18-13" title="13">          digits←¯1</a>
<a class="sourceLine" id="cb18-14" title="14">      :EndIf</a>
<a class="sourceLine" id="cb18-15" title="15">  :EndIf</a>
<a class="sourceLine" id="cb18-16" title="16">∇</a></code></pre></div>
<ul>
<li>If we don’t have the correct number of bits, we return <code>¯1</code>.</li>
<li>We test the first digit for its parity, to determine if its actually a left representation. If it’s not, we reverse the bit array.</li>
<li>Then, we take the bit array representing the right digits (<code>¯42↑¯3↓bits</code>), separate the different digits using <a href="https://help.dyalog.com/18.0/index.htm#Language/Primitive%20Functions/Partition.htm">Partition</a> (<code>⊆</code>), and look up each of them in the <code>rrepr</code> vector using <a href="https://help.dyalog.com/18.0/index.htm#Language/Primitive%20Functions/Index%20Of.htm">Index Of</a> (<code>⍳</code>). We do the same for the left digits.</li>
<li>Final checks for the range of the digits (i.e., if the representations could not be found in the <code>lrepr</code> and <code>rrepr</code> vectors), and for the check digit.</li>
</ul>
<h2 id="problem-8-balancing-the-scales">Problem 8 – Balancing the Scales</h2>
<div class="sourceCode" id="cb19"><pre class="sourceCode default"><code class="sourceCode default"><a class="sourceLine" id="cb19-1" title="1">∇ parts←Balance nums;subsets;partitions</a>
<a class="sourceLine" id="cb19-2" title="2">  ⍝ This is a brute force solution, running in</a>
<a class="sourceLine" id="cb19-3" title="3">  ⍝ exponential time. We generate all the possible</a>
<a class="sourceLine" id="cb19-4" title="4">  ⍝ partitions, filter out those which are not</a>
<a class="sourceLine" id="cb19-5" title="5">  ⍝ balanced, and return the first matching one. There</a>
<a class="sourceLine" id="cb19-6" title="6">  ⍝ are more advanced approach running in</a>
<a class="sourceLine" id="cb19-7" title="7">  ⍝ pseudo-polynomial time (based on dynamic</a>
<a class="sourceLine" id="cb19-8" title="8">  ⍝ programming, see the &quot;Partition problem&quot; Wikipedia</a>
<a class="sourceLine" id="cb19-9" title="9">  ⍝ page), but they are not warranted here, as the</a>
<a class="sourceLine" id="cb19-10" title="10">  ⍝ input size remains fairly small.</a>
<a class="sourceLine" id="cb19-11" title="11"></a>
<a class="sourceLine" id="cb19-12" title="12">  ⍝ Generate all partitions of a vector of a given</a>
<a class="sourceLine" id="cb19-13" title="13">  ⍝ size, as binary mask vectors.</a>
<a class="sourceLine" id="cb19-14" title="14">  subsets←{1↓2⊥⍣¯1⍳2*⍵}</a>
<a class="sourceLine" id="cb19-15" title="15">  ⍝ Keep only the subsets whose sum is exactly</a>
<a class="sourceLine" id="cb19-16" title="16">  ⍝ (+/nums)÷2.</a>
<a class="sourceLine" id="cb19-17" title="17">  partitions←nums{((2÷⍨+/⍺)=⍺+.×⍵)/⍵}subsets⍴nums</a>
<a class="sourceLine" id="cb19-18" title="18">  :If 0=≢,partitions</a>
<a class="sourceLine" id="cb19-19" title="19">      ⍝ If no partition satisfy the above</a>
<a class="sourceLine" id="cb19-20" title="20">      ⍝ criterion, we return ⍬.</a>
<a class="sourceLine" id="cb19-21" title="21">      parts←⍬</a>
<a class="sourceLine" id="cb19-22" title="22">  :Else</a>
<a class="sourceLine" id="cb19-23" title="23">      ⍝ Otherwise, we return the first possible</a>
<a class="sourceLine" id="cb19-24" title="24">      ⍝ partition.</a>
<a class="sourceLine" id="cb19-25" title="25">      parts←nums{((⊂,(⊂~))⊃↓⍉⍵)/¨2⍴⊂⍺}partitions</a>
<a class="sourceLine" id="cb19-26" title="26">  :EndIf</a>
<a class="sourceLine" id="cb19-27" title="27">∇</a></code></pre></div>
<h2 id="problem-9-upwardly-mobile">Problem 9 – Upwardly Mobile</h2>
<p>This is the only problem that I didn’t complete. It required parsing the files containing the graphical representations of the trees, which was needlessly complex and, quite frankly, hard and boring with a language like APL.</p>
<p>However, the next part is interesting: once we have a matrix of coefficients representing the relationships between the weights, we can solve the system of equations. <a href="https://help.dyalog.com/18.0/index.htm#Language/Primitive%20Functions/Matrix%20Divide.htm">Matrix Divide</a> (<code>⌹</code>) will find one solution to the system. Since the system is overdetermined, we fix <code>A=1</code> to find one possible solution. Since we want integer weights, the solution we find is smaller than the one we want, and may contain fractional weights. So we multiply everything by the <a href="https://help.dyalog.com/18.0/index.htm#Language/Primitive%20Functions/And%20Lowest%20Common%20Multiple.htm">Lowest Common Multiple</a> (<code>∧</code>) to get the smallest integer weights.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode default"><code class="sourceCode default"><a class="sourceLine" id="cb20-1" title="1">∇ weights←Weights filename;mobile;branches;mat</a>
<a class="sourceLine" id="cb20-2" title="2">  ⍝ Put your code and comments below here</a>
<a class="sourceLine" id="cb20-3" title="3"></a>
<a class="sourceLine" id="cb20-4" title="4">  ⍝ Parse the mobile input file.</a>
<a class="sourceLine" id="cb20-5" title="5">  mobile←↑⊃⎕NGET filename 1</a>
<a class="sourceLine" id="cb20-6" title="6">  branches←⍸mobile∊'┌┴┐'</a>
<a class="sourceLine" id="cb20-7" title="7">  ⍝ TODO: Build the matrix of coefficients mat.</a>
<a class="sourceLine" id="cb20-8" title="8"></a>
<a class="sourceLine" id="cb20-9" title="9">  ⍝ Solve the system of equations (arbitrarily setting</a>
<a class="sourceLine" id="cb20-10" title="10">  ⍝ the first variable at 1 because the system is</a>
<a class="sourceLine" id="cb20-11" title="11">  ⍝ overdetermined), then multiply the coefficients by</a>
<a class="sourceLine" id="cb20-12" title="12">  ⍝ their least common multiple to get the smallest</a>
<a class="sourceLine" id="cb20-13" title="13">  ⍝ integer weights.</a>
<a class="sourceLine" id="cb20-14" title="14">  weights←((1∘,)×(∧/÷))mat[;1]⌹1↓[2]mat</a>
<a class="sourceLine" id="cb20-15" title="15">∇</a></code></pre></div>
<div class="sourceCode" id="cb21"><pre class="sourceCode default"><code class="sourceCode default"><a class="sourceLine" id="cb21-1" title="1">    :EndNamespace</a>
<a class="sourceLine" id="cb21-2" title="2">:EndNamespace</a></code></pre></div>
    </section>
</article>


    <footer>
      Site proudly generated by
      <a href="http://jaspervdj.be/hakyll">Hakyll</a>
    </footer>
  </body>
</html>
